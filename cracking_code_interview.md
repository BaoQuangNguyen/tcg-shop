At the end of the interview, the interviewer will walkaway with a gut feel for how you did, A numeric score
might be assigned to your performance, but it's not actually a quantitative assessment.There's no chart that
says how many points you get for different things. It just doesn't work like that.

Rather, your interviewer will make an assessment of your performance, usually based on the following:

• Analytical skills: Did you need much help solving the problem? How optimal was your solution? How
  long did it take you to arrive at a solution? If you had to design/architect a new solution, did you struc-
  ture the problem well and think through the tradeoffs of different decisions?

• Coding skills: Were you able to successfully translate your algorithm to reasonable code? Was it clean
  and well-organized? Did you think about potential errors? Did you use good style?

• Technical knowledge / Computer Science fundamentals: Do you have a strong foundation in computer
  science and the relevant technologies?

• Experience: Have you made good technical decisions in the past? Have you built interesting, challenging
  projects? Have you shown drive, initiative, and other important factors?

• Culture fit / Communication skills: Do your personality and values fit with the company and team? Did
  you communicate well with your interviewer?

The weighting of these areas will vary based on the question, interviewer, role, team, and company. In a
standard algorithm question, it might be almost entirely the first three of those.

------------------------------------------------------------------------------------------------------------------------

Once you are selected for an interview, you usually go through a screening interview. This is typically
conducted over the phone. College candidates who attend top schools may have these interviews in-person.

Don't let the name fool you; the "screening" interview often involves coding and algorithms questions, and
the bar can be just as high as it is for in-person interviews. If you're unsure whether or not the interview will
be technical, ask your recruiting coordinator what position your interviewer holds (or what the interview
might cover). An engineer will usually perform a technical interview.

Many companies have taken advantage of online synchronized document editors, but others will expect
you to write code on paper and read it back over the phone. Some interviewers may even give you "home-
work" to solve after you hang up the phone or just ask you to email them the code you wrote.

You typically do one or two screening interviewers before being brought on-site.

In an on-site interview round, you usually have 3 to 6 in-person interviews. One of these is often over lunch.
The lunch interview is usually not technical, and the interviewer may not even submit feedback. This is a
good person to discuss your interests with and to ask about the company culture. Your other interviews wilt
be mostly technical and will involve a combination of coding, algorithm, design/architecture, and behav-
ioral/experience questions.

After your interview, your interviewers will provide feedback in some form, tn some companies, your inter-
viewers meet together to discuss your performance and come to a decision. In other companies, inter-
viewers submit a recommendation to a hiring manager or hiring committee to make a final decision. In
some companies, interviewers don't even make the decision; their feedback goes to a hiring committee to
make a decision.

Most companies get back after about a week with next steps (offer, rejection, further interviews, or just an
update on the process). Some companies respond much sooner (sometimes same day!) and others take
much longer.

If you have waited more than a week, you should follow up with your recruiter. If your recruiter does not
respond, this does not mean that you are rejected (at least not at any major tech company, and almost any
other company). Let me repeat that again; not responding indicates nothing about your status. The inten-
tion is that ali recruiters should tell candidates once a final decision is made.

Delays can and do happen. Follow up with your recruiter if you expect a delay, but be respectful when you
do. Recruiters are just like you. They get busy and forgetful too.

------------------------------------------------------------------------------------------------------------------------

• Getting the Right Experience

Without a great resume, there's no interview. And without great experience, there's no great resume. There-
fore, the first step in landing an interview is getting great experience. The further in advance you can think
about this the better.

For current students, this may mean the following:

• Take the Big Project Classes: Seek out the classes with big coding projects. This is a great way to get some-
  what practical experience before you have any formal work experience. The more relevant the project is
  to the real world, the better.

• Get an Internship: Do everything you can to land an internship early in school. It will pave the way for
  even better internships before you graduate. Many of the top tech companies have internship programs
  designed especially for freshman and sophomores. You can also look at startups, which might be more
  flexible.

• Starf Something: Build a project on your own time, participate in hackathons, or contribute to an open
  source project. It doesn't matter too much what it is. The important thing is that you're coding. Not only
  will this develop your technical skills and practical experience, your initiative will impress companies.

------------------------------------------------------------------------------------------------------------------------


Writing a Great Resume

Resume screeners look for the same things that interviewers do. They want to know that you're smart and
that you can code.

That means you should prepare your resume to highlight those two things. Your love of tennis, traveling, or
magic cards won't do much to show that. Think twice before cutting more technical lines in order to allow
space for your non-technical hobbies.


Appropriate Resume Length

In the US, it is strongly advised to keep a resume to one page if you have less than ten years of experience.
More experienced candidates can often justify 1.5 - 2 pages otherwise.

Think twice about a long resume. Shorter resumes are often more impressive.

• Recruiters only spend a fixed amount of time (about 10 seconds) looking at your resume. If you limit
  the content to the most impressive items, the recruiter is sure to see them. Adding additional items just
  distracts the recruiter from what you'd really like them to see.

• Some people just flat-out refuse to read long resumes. Do you really want to risk having your resume
  tossed for this reason?

If you are thinking right now that you have too much experience and can't fit it all on one or two pages,
trust me, you con. Long resumes are not a reflection of having tons of experience; they're a reflection of not
understanding how to prioritize content.


Employment History

Your resume does not—and should not—include a full history of every role you've ever had. Include only
the relevant positions—the ones that make you a more impressive candidate.

Writing Strong Bullets

For each role, try to discuss your accomplishments with the following approach:"Accomplished X by imple-
menting Y which led to Z." Here's an example:

• "Reduced object rendering time by 75% by implementing distributed caching, leading to a 10% reduc-
   tion in log-in time."

Here's another example with an alternate wording:

• "Increased average match accuracy from 1.2 to 1.5 by implementing a new comparison algorithm based
  on windiff."

Not everything you did will fit intothis approach, butthe principle is the same: show what you did, how you
did it, and what the results were. Ideally, you should try to make the results "measurable" somehow.


Projects
Developing the projects section on your resume is often the best way to present yourself as more experi-
enced. This is especially true for college students or recent grads.
The projects should include your 2 - 4 most significant projects. State what the project was and which
languages or technologies it employed. You may also want to consider including details such as whether
the project was an individual or a team project, and whether it was completed for a course or indepen-
dently, These details are not required, so only include them if they make you look better. Independent
projects are generally preferred over course projects, as it shows initiative.
Do not add too many projects. Many candidates make the mistake of adding all 13 of their prior projects,
cluttering their resume with small, non-impressive projects.
So what should you build? Honestly, it doesn't matter that much. Some employers really like open source
projects (it offers experience contributing to a large code base), while others prefer independent projects
(it's easier to understand your personal contributions). You could build a mobile app, a web app, or almost
anything.The most important thing is that you're building something.


Programming Languages and Software
Software
Be conservative about what software you list, and understand what's appropriate for the company. Soft-
ware like Microsoft Office can almost always be cut. Technical software like Visual Studio and Eclipse is
somewhat more relevant, but many of the top tech companies won't even care about that. After all, is it
really that hard to learn Visual Studio?
Of course, it won't hurt you to list all this software. It just takes up valuable space. You need to evaluate the
trade-off of that.
Languages
Should you list everything you've ever worked with, or shorten the list to just the ones that you're most
comfortable with?
Listing everything you've ever worked with is dangerous. Many interviewers consider anything on your
resume to be "fair game"as far as the interview.
One alternative is to list most of the languages you've used, but add your experience level. This approach
is shown below:
• Languages: Java (expert), C++ (proficient), JavaScript (prior experience).
Use whatever wording ("expert" "fluent" etc.) effectively communicates your skillset.
Some people list the number of years of experience they have with a particular language, but this can be
really confusing. If you first learned Java 10 years ago, and have used it occasionally throughout that time,
how many years of experience is this?
For this reason, the number of years of experience is a poor metric for resumes. It's better to just describe
what you mean in plain English.

Beware of (Potential) Stigma
Certain languages have stigmas associated with them. Sometimes this is because of the language them-
selves, but often it's because of the places where this language is used. I'm not defending the stigma; I'm
just letting you know of it,
A few stigmas you should be aware of;
• Enterprise Languages: Certain languages have a stigma associated with them, and those are often the
ones that are used for enterprise development. Visual Basic is a good example of this. If you show your-
self to be an expert with VB, it can cause people to assume that you're less skilled. Many of these same
people will admit that, yes, VB.NET is actually perfectly capable of building sophisticated applications.
But still, the kinds of applications that people tend to build with it are not very sophisticated. You wouid
be unlikely to see a big name Silicon Valley using VB.
In fact, the same argument (although less strong) applies to the whole .NET platform. If your primary
focus is .NET and you're not applying for .NET roles, you'll have to do more to show that you're strong
technically than if you were coming in with a different background.
• Being Too Language Focused: When recruiters at some of the top tech companies see resumes that
list every flavor of Java on their resume, they make negative assumptions about the caliber of candi-
date. There is a belief in many circles that the best software engineers don't define themselves around
a particular language. Thus, when they see a candidate seems to flaunt which specific versions of a
language they know, recruiters will often bucket the candidate as "not our kind of person."
Note that this does not mean that you should necessarily take this'language flaunting" off your resume.
You need to understand what that company values. Some companies do value this.
• Certifications: Certifications for software engineers can be anything from a positive, to a neutral, to
a negative. This goes hand-in-hand with being too language focused; the companies that are biased
against candidates with a very lengthy list of technologies tend to also be biased against certifications.
This means that in some cases, you should actually remove this Sort of experience from your resume.
• Knowing Only One or Two Languages: The more time you've spent coding, the more things you've
built, the more languages you will have tended to work with. The assumption then, when they see a
resume with only one language, is that you haven't experienced very many problems. They also often
worry that candidates with only one or two languages will have trouble learning new technologies (why
hasn't the candidate learned more things?) or wiil just feel too tied with a specific technology (poten-
tially not using the best language for the task).
This advice is here not just to help you work on your resume, but also to help you develop the right experi-
ence. If your expertise isinCJf.NET, try developing some projects in Python and JavaScript. If you only know
one or two languages, build some applications in a different language.
Where possible, try to truly diversify. The languages in the cluster of {Python, Ruby, and JavaScript) are
somewhat similar to each other. It's better if you can learn languages that are more different, like Python,
C++, and Java.

------------------------------------------------------------------------------------------------------------------------

Behavioral Questions

Behavioral questions are asked to get to know your personality, to understand your resume more deeply,
and just to ease you into an interview. They are important questions and can be prepared for.

Interview Preparation Grid
Go through each of the projects or components of your resume and ensure that you can talk about them in
detail. Filling out a grid like this may help:

    Common Questions          | Project 1 | Project 2 | Project 3
    Challenges                |           |           |
    Mistakes/Failures         |           |           |
    Enjoyed                   |           |           |
    Leadership                |           |           |
    Conflicts                 |           |           |
    What You'd Do Differently |           |           |

What You'd Do Differently
Along the top, as columns, you should list all the major aspects of your resume, including each project, job,
or activity. Along the side, as rows, you should list the common behavioral questions.
Study this grid before your interview. Reducing each story to just a couple of keywords may make the grid
easier to study and recall. You can also more easily have this grid in front of you during an interview without
it being a distraction.
In addition, ensure that you have one to three projects that you can talk about in detail. You should be able
to discuss the technical components in depth. These should be projects where you played a central role.


What are your weaknesses?
When asked about your weaknesses, give a real weakness! Answers like "My greatest weakness is that I
work too hard" tell your interviewer that you're arrogant and/or won't admit to your faults. A good answer
conveys a real, legitimate weakness but emphasizes how you work to overcome it.
For example:
I"Sometimes, I don't have a very good attention to detail. While that's good because it lets me
execute quickly, it also means that I sometimes make careless mistakes. Because of that, I make
sure to always have someone else double check my work."

What questions should you ask the interviewer?
Most interviewers will give you a chance to ask them questions. The quality of your questions will be a
factor, whether subconsciously or consciously, in their decisions. Walk into the interview with some ques-
tions in mind.
You can think about three general types of questions.
Genuine Questions
These are the questions you actually want to know the answers to. Here are a few ideas of questions that
are valuable to many candidates:
1. "What is the ratio of testers to developers to program managers? What is the interaction like? How does
project planning happen on the team?"
2. "What brought you to this company? What has been most challenging for you?"
These questions will give you a good feel for what the day-to-day life is like at the company.
Insightful Questions
These questions demonstrate your knowledge or understanding of technology.
1. "I noticed that you use technology X. How do you handle problem Y?"
2, "Why did the product choose to use the X protocol over the Y protocol? I know it has benefits like A, 8,
C, but many companies choose not to use it because of issue D."
Asking such questions will typically require advance research about the company.
Passion Questions
These questions are designed to demonstrate your passion for technology. They show that you're inter-
ested tn learning and will be a strong contributor to the company.
1. "I'm very interested in scalability, and I'd love to learn more about it. What opportunities are there at this
company to learn about this?"
2. "I'm not familiar with technology X, but it sounds like a very interesting solution. Could you tell me a bit
more about how it works?"
> KnowYourTechnical Projects
As part of your preparation, you should focus on two or three technical projects that you should deeply
master. Select projects that ideally fit the following criteria:
• The project had challenging components (beyond just "learning a lot").
• You played a central role (ideally on the challenging components).
• You can talk at technical depth.
For those projects, and all your projects, be able to talk about the challenges, mistakes, technical decisions,
choices of technologies (and tradeoffs of these), and the things you would do differently.
You can also think about follow-up questions, like how you would scale the application.

Responding to Behavioral Questions
Behavioral questions allow your interviewer to get to know you and your prior experience better. Remember
the following advice when responding to questions.
Be Specific, Not Arrogant
Arrogance is a red flag, but you still want to make yourself sound impressive. So how do you make yourself
sound good without being arrogant? By being specific!
Specificity means giving just the facts and letting the interviewer derive an interpretation. For example,
rather than saying that you "did all the hard parts,"you can instead describe the specific bits you did that
were challenging.
Limit Details
When a candidate blabbers on about a problem, it's hard for an interviewer who isn't well versed in the
subject or project to understand it.
Stay tight on details and just state the key points. When possible, try to translate it or at least explain the
impact. You can always offer the interviewer the opportunity to drill in further.
I"By examining the most common user behavior and applying the Rabin-Karp algorithm, I
designed a new algorithm to reduce search from 0 { n ) to 0 ( l o g n) in 90% of cases. I can go
into more details if you'd like."
This demonstrates the key points while letting your interviewer ask for more details if he wants to.
Focus on Yourself, Not Your Team
Interviews are fundamentally an individual assessment. Unfortunately, when you listen to many candidates
(especially those in leadership roles), their answers are about "we", "us", and "the team." The interviewer
walks away having little idea what the candidate's actual impact was and might conclude that the candi-
date did little.
Pay attention to your answers. Listen for how much you say "we" versus "I." Assume that every question is
about your role, and speak to that.
Give Structured Answers
There are two common ways to think about structuring responses to a behavioral question: nugget first
and S.A.R, These techniques can be used separately or together.
Nugget First
Nugget First means starting your response with a "nugget" that succinctly describes what your response
will be about.
For example:
• Interviewer: "Tell me about a time you had to persuade a group of people to make a big change."
• Candidate:"Sure, let me tell you about the time when I convinced my school to let undergraduates teach
their own courses. Initially, my school had a rule where..."
This technique grabs your interviewer's attention and makes it very ciear what your story will be about It
also helps you be more focused in your communication, since you've made it very clear to yourself what
the gist of your response is.

S.A.R. (Situation, Action, Result)
The S.A.R, approach means that you start off outlining the situation, then explaining the actions you took,
and lastly, describing the result.
Example:"Tell me about a challenging interaction with a teammate."
• Situation: On my operating systems project, I was assigned to work with three other people. While two
were great, the third team member didn't contribute much. He stayed quiet during meetings, rarely
chipped in during email discussions, and struggled to complete his components. This was an issue not
only because it shifted more work onto us, but also because we didn't know if we could count on him.
• Action: I didn't want to write him off completely yet, so I tried to resoive the situation. I did three things.
First, I wanted to understand why he was acting like this. Was it laziness? Was he busy with something
else? I struck up a conversation with him and then asked him open-ended questions about how he felt it
was going. Interestingly, basically out of nowhere, he said that he wanted to take on the writeup, which
is one of the most time intensive parts. This showed me that it wasn't laziness; it was that he didn't feel
like he was good enough to write code.
Second, now that I understand the cause, I tried to make it clear that he shouldn't fear messing up, I told
him about some of the bigger mistakes that I made and admitted that I wasn't ciear about a lot of parts
of the project either.
Third and finally, 1 asked him to help me with breaking out some of the components of the project. We
sat down together and designed a thorough spec for one of the big component, in much more detail
than we had before. Once he could see all the pieces, it helped show him that the project wasn't as scary
as he'd assumed.
• Result: With his confidence raised, he now offered to take on a bunch of the smaller coding work, and
then eventually some of the biggest parts. He finished all his work on time, and he contributed more in
discussions. We were happy to work with him on a future project.
The situation and the result should be succinct. Your interviewer generally does not need many details to
understand what happened and, in fact, may be confused by them.
By using the S.A.R, model with clear situations, actions and results, the interviewer will be able to easily
identify how you made an impact and why it mattered.

Explore the Action
In almost all cases, the "action" is the most important part of the story. Unfortunately, far too many people
talk on and on about the situation, but then just breeze through the action.
Instead, dive into the action. Where possible, breakdown the action into multiple parts. For example:"! did
three things. First, I..."This will encourage sufficient depth.
Think About What It Says
Re-read the story on page 35. What personality attributes has the candidate demonstrated?
• Initiative/Leadership: The candidate tried to resolve the situation by addressing it head-on.
• Empathy; The candidate tried to understand what was happening to the person. The candidate also
showed empathy in knowing what would resolve the teammate's insecurity.
• Compassion: Although the teammate was harming the team, the candidate wasn't angry at the team-
mate. His empathy led him to compassion.
• Humility: The candidate was able to admit to his own flaws (not only to the teammate, but also to the
interviewer),
• Teamwork/Helpfulness: The candidate worked with the teammate to break down the project into
manageable chunks.
You should think about your stories from this perspective. Analyze the actions you took and how you
reacted. What personality attributes does your reaction demonstrate?
In many cases, the answer is"none."That usually means you need to rework how you communicate the story
to make the attribute clearer. You don't want to explicitly say, "I did X because I have empathy," but you can
go one step away from that. For example:
• Less Clear Attribute:"! called up the client and told him what happened."
• More Clear Attribute (Empathy and Courage): "I made sure to call the client myself, because I knew
that he would appreciate hearing it directly from me,"
If you still can't make the personality attributes clear, then you might need to come up with a new story
entirely.

So, tell me about yourself...
Many interviewers kick off the session by asking you to tell them a bit about yourself, or asking you to walk
through your resume. This is essentially a "pitch". It's your interviewer's first impression of you, so you want
to be sure to nail this.
Structure
A typical structure that works well for many people is essentially chronological, with the opening sentence
describing their current job and the conclusion discussing their relevant and interesting hobbies outside
of work (if any).
1. Current Role [Headline Only): "I'm a software engineer at Microworks, where I've been leading the
Android team for the last five years."
2. College: My background is in computer science, I did my undergrad at Berkeley and spent a few
summers working at startups, including one where I attempted to launch my own business,
3. Post College & Onwards: After college, I wanted to get some exposure to larger corporations so I joined
Amazon as a developer. It was a great experience. I learned a ton about large system design and I got to
really drive the launch of a key part of AWS. That actually showed me that I really wanted to be in a more
entrepreneurial environment.
4. Current Role (Details): One of my old managers from Amazon recruited me out to join her startup,
which was what brought me to Microworks. Here, I did the initial system architecture, which has scaled
pretty well with our rapid growth. I then took an opportunity to lead the Android team. I do manage a
team of three, but my rote is primarily with technical leadership: architecture, coding, etc.
5. Outside of Work: Outside of work, I've been participating in some hackathons—mostly doing iOS
development there as a way to learn it more deeply. I'm also active as a moderator on online forums
around Android development.
6. Wrap Up: I'm looking now for something new, and your company caught my eye. I've always loved the
connection with the user, and I really want to get back to a smaller environment too.
This structure works well for about 95% of candidates. For candidate with more experience, you might
condense part of it. Ten years from now, the candidate's initial statements might become just: "After my
CS degree from Berkeley, I spent a few years at Amazon and then joined a startup where I led the Android
team."

Hobbies
Think carefully about your hobbies. You mayor may not want to discuss them.
Often they're just fluff. If your hobby is just generic activities like skiing or playing with your dog, you can
probably skip it.
Sometimes though, hobbies can be useful. This often happens when:
• The hobby is extremely unique (e.g., fire breathing). It may strike up a bit of a conversation and kick off
the interview on a more amiable note.
• The hobby is technical.This not only boosts your actual skillset, but it also shows passion for technology.
• The hobby demonstrates a positive personality attribute. A hobby I ike "remodeling your house yourself"
shows a drive to learn new things, take some risks, and get your hands dirty (literally and figuratively).
It would rarely hurt to mention hobbies, so when in doubt, you might as well.
Think about how to best frame your hobby though. Do you have any successes or specific work to show
from it (e.g., landing a part in a play)? Is there a personality attribute this hobby demonstrates?

Sprinkle in Shows of Successes
In the above pitch, the candidate has casually dropped in some highlights of his background.
• He specifically mentioned that he was recruited out of Microworks by his old manager, which shows that
he was successful at Amazon.
» He also mentions wanting to be in a smaller environment, which shows some element of culture fit
(assuming this is a startup he's applying for).
• He mentions some successes he's had, such as launching a key part of AWS and architecting a scalable
system.
• He mentions his hobbies, both of which show a drive to learn.
When you think about your pitch, think about what different aspects of your background say about you.
Can you can drop in shows of successes (awards, promotions, being recruited out by someone you worked
with, launches, etc.)? What do you want to communicate about yourself?

------------------------------------------------------------------------------------------------------------------------

BigO

This is such an important concept that we are dedicating an entire (long') chapter to it.

Big 0 time is the language and metric we use to describe the efficiency of algorithms. Not understanding
it thoroughly can really hurt you in developing an algorithm. Not only might you be judged harshly for
not really understanding big 0, but you will also struggle to judge when your algorithm is getting faster or
slower. Master this concept.


An Analogy
Imagine the following scenario: You've got a file on a hard drive and you need to send it to your friend who
lives across the country. You need to get the file to your friend as fast as possible. How should you send it?
Most people's first thought would be email, FTP, or some other means of electronic transfer. That thought is
reasonable, but only haif correct.
If it's a small file, you're certainly right, it would take 5 - 1 0 hours to get to an airport, hop on a flight, and
then deliver it to your friend.
But what if the file were really, really large? Is it possible that it's faster to physically deliver it via plane?
Yes, actually it is, A one-terabyte (1 T8) file could take more than a day to transfer electronically. It would be
much faster to just fly it across the country. If your file is that urgent (and cost isn't an issue), you might just
want to do that.
What if there were no flights, and instead you had to drive across the country? Even then, for a really huge
file, it would be faster to drive.

• Time Complexity
This is what the concept of asymptotic runtime, or big 0 time, means. We could describe the data transfer
"algorithm" runtime as:
• Electronic Transfer: 0 ( s ) , where s is the size of the file. This means that the time to transfer the file
increases linearly with the size of the file. (Yes, this is a bit of a simplification, but that's okay for these
purposes.)
• Airplane Transfer: 0 ( 1 ) with respect to the size of the file. As the size of the file increases, it won't take
any longer to get the file to your friend. The time is constant.
No matter how big the constant is and how slow the linear increase is, linear will at some point surpass
constant.

Big O, Big Theta, and Big Omega
If you've never covered big 0 in an academic setting, you can probably skip this subsection. It might
confuse you more than it helps. This "FYI" is mostly here to clear up ambiguity in wording for people who
have learned big 0 before, so that they don't say, "But I thought big 0 meant..."
Academics use big 0, big 0 (theta), and big Q (omega) to describe runtimes.
• 0 (big O): In academia, big 0 describes an upper bound on the time. An algorithm that prints all the
values in an array could be described asO(N), but it could also be described as O f N ^ J . O ^ ) , or 0(2N )
(or many other big 0 times). The algorithm is at least as fast as each of these; therefore they are upper
bounds on the runtime. This is similar to a less-than-or-equai-to relationship. If Bob is X years old (t'H
assume no one lives past age 130), then you could say X < 130. It would also be correct to say that
X < l , 0 @ 0 o r X < 1,008,660. It's technically true (although not terribly useful). Likewise, a simple
algorithm to print the values in an array isO(N) as well asO(M3) or any runtime bigger than 0(N).
* Q (big omega): In academia, 0 is the equivalent concept but for lower bound. Printing the values in
an array is fl(N) as well as fi(log M) and Q ( l ) . After all, you know that it won't be faster than those
runtimes.
• 0 (big theta): In academia, 0 means both 0 and fi. That is, an algorithm is 0 (N) if it is both 0( N) and
0(N). 0 gives a tight bound on runtime.
In industry (and therefore in interviews), people seem to have merged© and 0 together. Industry's meaning
of big 0 is closer to what academics mean by 0, in that it would be seen as incorrect to describe printing an
array as 0(N? ). Industry would just say this is 0(N).
For this book, we will use big 0 in the way that industry tends to use it; By always trying to offer the tightest
description of the runtime.

Best Case, Worst Case, and Expected Case
We can actually describe our runtime for an algorithm in three different ways.
Let's look at this from the perspective of quicksort. Quick sort picks a random element as a "pivot"and then
swaps values in the array such that the elements less than pivot appear before elements greater than pivot.
This gives a "partial sorf'Then it recursively sorts the left and right sides using a similar process.
• Best Case: If all elements are equal, then quick sort will, on average, just traverse through the array once.
This is 0 ( N ) . (This actually depends slightly on the implementation of quick sort. There are implementa-
tions, though, that will run very quickly on a sorted array.)
• Worst Case: What if we get really unlucky and the pivot is repeatedly the biggest element in the array?
(Actually, this can easily happen. If the pivot is chosen to be the first element in the subarray and the
array is sorted in reverse order, we'll have this situation.) In this case, our recursion doesn't divide the
array in half and recurse on each half. It just shrinks the subarray by one element. This will degenerate
to anO(N^) runtime.
• Expected Case: Usually, though, these wonderful or terrible situations won't happen. Sure, sometimes
the pivot will be very low or very high, but it won't happen over and over again. We can expect a runtime
o f 0 ( N l o g N).
We rarely ever discuss best case time complexity, because it's not a very useful concept. After all, we could
take essentially any algorithm, special case some input, and then get an 0 ( 1 ) time in the best case.
For many—probably most—algorithms, the worst case and the expected case are the same. Sometimes
they're different, though, and we need to describe both of the runtimes.
What is the relationship between best/worst/expected case and big O/theta/omega?
It's easy for candidates to muddle these concepts (probably because both have some concepts of "higher"
"lower"and "exactly right"), but there is no particular relationship between the concepts.
Best, worst, and expected cases describe the big 0 (or big theta) time for particular inputs or scenarios.
Big 0, big omega, and big theta describe the upper, lower, and tight bounds for the runtime.

Space Complexity
Time is not the only thing that matters in an algorithm. We might also care about the amount of memory—
or space—required by an algorithm.
Space complexity is a parallel concept to time complexity. If we need to create an array of size n, this will
require 0 ( n ) space. If we need a two-dimensional array of size nxn, this will require 0 ( n * ) space.
Stack space in recursive calls counts, too. For example.code like this would take 0( n) time and 0( n) space.

1 int sum(int n) { /* Ex l . V
2   if (n <= 0) {
3       return &;
4   >
5   return n + sum(n-l);
6 }
Each call adds a level to the stack.
1   sum(4)
2       -> sum(3)
3           -> sum(2)
4                   sum(l)
5                   -> sum(0)

Each of these calls is added to the call stack and takes up actual memory.

However, just because you have n calls total doesn't mean it takes O ( n ) space. Consider the below func-
tion, which adds adjacent elements between 0 and n:

1 int pairSumSequencefint n) { /* Ex 2.*/
2   i n t sum = 0;
3   for (int i = 0; i < n; i++) {
4       sum += pairSum(ij i + 1);
5   }
6   return sum;
7 >
8
9 int pairSum(int a, int b) {
10  return a + b;
11 >

There will be roughly O(n) calls to pairSum. However, those calls do not exist simultaneously on the call
stack, so you only need 0 ( 1 ) space.

Drop the Constants
It is very possible for 0 ( N ) code to run faster than 0 ( 1 ) code for specific inputs. Sig 0 just describes the
rate of increase.
For this reason, we drop the constants in runtime. An algorithm that one might have described as 0( 2N)
isactuallyO(N).
Many people resist doing this. They will see code that has two (non-nested) for loops and continue this
0 ( 2 N ) . They think they're being more "precise." They're not.
Consider the below code: (refer to page 41)
Which one is faster? The first one does one for loop and the other one does two for loops. But then, the first
solution has two lines of code per for loop rather than one.
If you're going to count the number of instructions, then you'd have to go to the assembly level and take
into account that multiplication requires more instructions than addition, how the compiler would opti-
mize something, and all sorts of other details.
This would be horrendously complicated, so don't even start going down this road. Big O allows us to
express how the runtime scales. We just need to accept that it doesn't mean that 0( N) is always better than
0(NJ ).

Drop the Non-Dominant Terms
What do you do about ari expression such as 0(N3 + N)?That second N isn't exactly a constant. But it's
not especially important.
We already said that we drop constants.Therefore, 0(NJ + N2) would be 0 (N?)- If we don't care about that
latter NJ term, why would we care about N? We don't.
You should drop the non-dominant terms,
• 0(N2 + N) becomesO(Nz).
• 0(N + l o g N) becomesO(M).
• 0(5*2N + ie00N100) becomes 0(2S ).
We might still have a sum in a runtime. For example, the expression 0(B? + A) cannot be reduced (without
some special knowledge of A and B).
The following graph depicts the rate of increase for some of the common big 0 times. (page 50)

Multi-Part Algorithms: Add vs. Multiply
Suppose you have an algorithm that has two steps. When do you multiply the runtimes and when do you
add them?
This is a common source of confusion for candidates. (page 51)
In the example on the left, we do A chunks of work then B chunks of work. Therefore, the total amount of
work isO(A + B).
In the example on the right, we do B chunks of work for each element in A. Therefore, the total amount of
work isO(A * 8).
In other words:
• If your algorithm is in the form "do this, then, when you're all done, do that" then you add the runtimes.
• If your algorithm is in the form "do this for each time you do that" then you multiply the runtimes.
It's very easy to mess this up in an interview, so be careful.

Amortized Time
An A r r a y L i s t , or a dynamically resizing array, allows you to have the benefits of an array while offering
flexibility in size. You won't run out of space in the A r r a y L i s t since its capacity will grow as you insert
elements.
An ArrayList is implemented with an array. When the array hits capacity, the A r r a y L i s t class will create a
new array with double the capacity and copy all the elements over to the new array.
How do you describe the runtime of insertion? This is a tricky question.
The array could be full. If the array contains N elements, then inserting a new element will takeO(N) time.
You will have to create a new array of size 2N and then copy N elements over. This insertion will takeO(N)
time.
However, we also know that this doesn't happen very often. The vast majority of the time insertion will be
in 0 ( 1 ) time.
We need a concept that takes both into account. This is what amortized time does. It allows us to describe
that, yes, this worst case happens every once in a while. But once it happens, it won't happen again for so
long that the cost is "a mortized."
In this case, what is the amortized time?
As we insert elements, we double the capacity when the size of the array is a power of 2. So after X elements,
we double the capacity at array sizes 1, 2,4,8,16,..., X. That doubling takes, respectively, 1,2,4, 8,16,32,
64,.,., X copies.
What is the sum of 1 + 2 + 4 + 8 + 16 + ... + X? If you read this sum left to right, it starts with 1 and doubles
until it gets to X. If you read right to left, it starts with X and halves until it gets to 1.
What then is the sum ofX + *A + + % +...+ 1?This Is roughly 2X.
Therefore, X insertions take0(2X) time. The amortized time for each insertion is 0 ( 1 ) ,

Log N Runtimes
We commonly see 0( l o g N) in runtimes. Where does this come from?
Let's look at binary search as an example, In binary search, we are looking for an example x in an N-element
sorted array. We first compare x to the midpoint of the array. If x — m i d d l e , then we return. If x <
m i d d l e , then we search on the left side of the array. If x > m i d d l e , then we search on the right side of
the array.
search 9 within {1, 5, 8, 9, 11, 13, 15, 19, 21}
compare 9 to 11 -> smaller,
search 9 within {1, 5, 8, 9, 11}
compare 9 to 8 -> bigger
search 9 within {9, 11}
compare 9 to 9
return
We start off with an N-element array to search. Then, after a single step, we're down to "/i elements. One
more step, and we're down to H/t, elements. We stop when we either find the value or we're down to just
one element.
The total runtime is then a matter of how many steps (dividing N by 2 each time) we can take until N
becomes 1.
N = 16
N = 8 /* divide by 2 */
M = 4 /* divide by 2 */
N = 2 /* divide by 2 V
N = 1 /* divide by 2 V
We could look at this in reverse (going from 1 to 16 instead of 16 to 1). How many times we can multiply 1
by 2 until we get N?
N = 1
N = 2 /* multiply by 2 */
N = 4 /* multiply by 2 */
N = 8 !* multiply by 2 */
N = 16 /* multiply by 2 */
What is k in the expression 2k = N? This is exactly what l o g expresses.
T - 16 -> log;
16 = 4
log;
N = k -> 2* = N
This is a good takeaway for you to have. When you see a problem where the number of elements in the
problem space gets halved each time, that will likely be a 0( l o g N) runtime.
This is the same reason why finding an element in a balanced binary search tree is O ( l o g N). With each
comparison, we go either left or right. Half the nodes are on each side, so we cut the problem space in half
each time.
What's the base of the log? That's an excellent question! The short answer is that it doesn't matter

------------------------------------------------------------------------------------------------------------------------

Technical Questions
Technical questions form the basis for how many of the top tech companies interview. Many candidates are
intimidated by the difficulty of these questions, but there are logical ways to approach them.

How to Prepare
Many candidates just read through problems and solutions. That's like trying to learn calculus by reading a
problem and its answer. You need to practice solving problems. Memorizing solutions won't help you much.
For each problem in this book (and any other problem you might encounter), do the following:
J. Try to solve the problem on your own. Hints are provided at the back of this book, but push yourself to
develop a solution with as little help as possible. Many questions are designed to be tough—that's okay!
When you're solving a problem, make sure to think about the space and time efficiency.
2. Write the code on paper. Coding on a computer offers luxuries such as syntax highlighting, code comple-
tion, and quick debugging. Coding on paper does not. Get used to this—and to how slow it is to write
and edit code—by coding on paper.
3. Test your code—on paper. This means testing the general cases, base cases, error cases, and so on. You'll
need to do this during your interview, so it's best to practice this in advance.
4. Type your paper code as-is into a computer. You will probably make a bunch of mistakes. Start a list of all
the errors you make so that you can keep these in mind during the actuai interview.
In addition, try to do as many mock interviews as possible. You and a friend can take turns giving each other
mock interviews. Though your friend may not be an expert interviewer, he or she may still be able to walk
you through a coding or algorithm problem. You'll also learn a lot by experiencing what it's like to be an
interviewer.

What You Need To Know
The sorts of data structure and algorithm questions that many companies focus on are not knowledge
tests. However, they do assume a baseline of knowledge.

Core Data Structures, Algorithms, and Concepts
Most interviewers won't ask about specific algorithms for binary tree balancing or other complex algo-
rithms. Frankly, being several years out of school, they probably don't remember these algorithms either.
You're usually only expected to know the basics. Here's a list of the absolute, must-have knowledge:

Data Structures        |     Algorithms       |    Concepts  

Linked Lists           | Breadth-First Search | Bit Manipulation
Trees, Tries, & Graphs | Depth-First Search   | Memory (Stack vs. Heap)
Stacks & Queues        | Binary Search        | Recursion
Heaps                  | Merge Sort           | Dynamic Programming
Vectors/ArrayLists     | Quick Sort           | Big 0 Time & Space
Hash Tables

For each of these topics, make sure you understand how to use and implement them and, where applicable,
the space and time complexity.
Practicing implementing the data structures and algorithm (on paper, and then on a computer) is also a
great exercise. It will help you learn how the internals of the data structures work, which is important for
many interviews.

Did you miss that paragraph above? It's important. If you don't feel very, very comfortable with
each of the data structures and algorithms listed, practice implementing them from scratch.

In particular, hash tables are an extremely important topic. Make sure you are very comfortable with this
data structure.

Walking through a problem (page 74 in preview for flowchart)
What to Expect
Interviews are supposed to be difficult. If you don't get every—or any—answer immediately, that's okay!
That's the normal experience, and it's not bad.
Listen for guidance from the interviewer.The interviewer might take a more active or less active roie in your
problem solving. The level of interviewer participation depends on your performance, the difficulty of the
question, what the interviewer is looking for, and the interviewer's own personality.
When you're given a problem (or when you're practicing), work your way through it using the approach
below.

1. Listen Carefully
You've likely heard this advice before, but I'm saying something a bit more than the standard "make sure
you hear the problem correctly"advice.
Yes, you do want to listen to the problem and make sure you heard it correctly. You do want to ask questions
about anything you're unsure about.
But I'm saying something more than that.
Listen carefully to the problem, and be sure that you've mentally recorded any unique information in the
problem.
For example, suppose a question starts with one of the following lines. It's reasonable to assume that the
information is there for a reason.
• "Given two arrays that are sorted, find..."
You probably need to know that the data is sorted. The optimal algorithm for the sorted situation is
probably different than the optimal algorithm for the unsorted situation.
• "Design an algorithm to be run repeatedly on a server that..."
The server/to-be-run-repeatedly situation is different from the run-once situation. Perhaps this means
that you cache data? Or perhaps it justifies some reasonable precomputation on the initial dataset?
It's unlikely (although not impossible) that your interviewer would give you this information if it didn't affect
the algorithm.
Many candidates will hear the problem correctly. But ten minutes into developing an algorithm, some of
the key details of the problem have been forgotten. Now they are in a situation where they actually can't
solve the problem optimally.
Your first algorithm doesn't need to use the information. But if you find yourself stuck, or you're still working
to develop something more optimal, ask yourself if you've used all the information in the problem.
You might even find it useful to write the pertinent information on the whiteboard.

2, Draw an Example
An example can dramatically improve your ability to solve an interview question, and yet so many candi-
dates just try to solve the question in their heads.
When you hear a question, get out of your chair, go to the whiteboard, and draw an example.
There's an art to drawing an example though. You want a good example.
Very typically, a candidate might draw something like this for an example of a binary search tree: (page 76 for figure)
This is a bad example for several reasons. First, it's too small. You will have trouble finding a pattern in such
a small example. Second, it's not specific. A binary search tree has values. What if the numbers tell you
something about how to approach the problem? Third, it's actually a special case. It's not just a balanced
tree, but it's also a beautiful, perfect tree where every node other than the leaves has two children. Special
cases can be very deceiving.
Instead, you want to create an example that is:
• Specific. It should use real numbers or strings (if applicable to the problem).
• Sufficiently large. Most examples are too small, by about 50%,
• Not a special case. Be careful, it's very easy to inadvertently draw a special case. If there's any way your
example is a special case (even if you think it probably won't be a big deal), you should fix it,
Try to make the best example you can. If it later turns out your example isn't quite right, you canandshouid
fix it.

3. State a Brute Force
Once you have an example done (actually, you can switch the order of steps 2 and 3 in some problems),
state a brute force. It's okay and expected that your initial algorithm won't be very optimal.
Some candidates don't state the brute force because they think it's both obvious and terrible. But here's the
thing: Even if it's obvious for you, it's not necessarily obvious for all candidates. You don't want your inter-
viewer to think that you're struggling to see even the easy solution.
It's okay that this initial solution is terrible. Explain what the space and time complexity is, and then dive
into improvements.
Despite being possibly slow, a brute force algorithm is valuable to discuss. It's a starting point for optimiza-
tions, and it helps you wrap your head around the problem.

4. Optimize
Once you have a brute force algorithm, you should work on optimizing it. A few techniques that work well
are:
1. Look for any unused information. Did your interviewer tell you that the array was sorted? How can you
leverage that information?
2. Use a fresh example. Sometimes, just seeing a different example will unclog your mind or help you see
a pattern in the problem.
3. Solve it "incorrectly." Just like having an inefficient solution can help you find an efficient solution, having
an incorrect solution might help you find a correct solution. For example, if you're asked to generate a
random value from a set such that all values are equally likely, an incorrect solution might be one that
returns a semi-random value: Any value could be returned, but some are more likely than others. You
can then think about why that solution isn't perfectly random. Can you rebalance the probabilities?
4. Make time vs. space tradeoff. Sometimes storing extra state about the problem can help you optimize
the runtime.
5. Precompute information. Is there a way that you can reorganize the data (sorting, etc.) or compute some
values upfront that will help save time in the long run?
6. Use a hash table. Hash tables are widely used in interview questions and should be at the top of your
mind.
7. Think about the best conceivable runtime (discussed on page 72).
Walk through the brute force with these ideas in mind and look for BUD (page 67).

5. Walk Through
After you've nailed down an optimal algorithm, don't just dive into coding. Take a moment to solidify your
understanding of the algorithm.
Whiteboard coding is slow—very slow. So is testing your code and fixing it. As a result, you need to make
sure that you get it as close to "perfect" in the beginning as possible.
Walkthrough your algorithm and get a feel for the structure of the code. Know what the variables are and
when they change.
What about pseudocode? You can write pseudocode if you'd like. Be careful about what you
write. Basic steps ("(1) Search array. (2) Find biggest, (3) Insert in heap.") or brief logic ("if p <
q, move p. else move q") can be valuable. But when your pseudocode starts having for loops
that are written in plain English, then you're essentially just writing sloppy code. It'd probably be
faster to just write the code.
if you don't understand exactly what you're about to write, you'll struggle to code it. It will take you longer
to finish the code, and you're more likely to make major errors.

6. Implement
Now that you have an optimal algorithm and you know exactly what you're going to write, go ahead and
implement it.
Start coding in the far top left corner of the whiteboard (you'll need the space). Avoid "line creep" (where
each line of code is written an awkward slant), it makes your code look messy and can be very confusing
when working in a whitespace-sensitive language, like Python.
Remember that you only have a short amount of code to demonstrate that you're a great developer. Every-
thing counts. Write beautiful code.
Beautiful code means:
• Modularized code. This shows good coding style. It also makes things easier for you. If your algorithm
uses a matrix initialized to { { 1 j 2, 3 } , { 4 , 5, 6}, }, don't waste your time writing this
initialization code. Just pretend you have a function i n i t Increment a l M a t r i x ( i n t s i z e ) . Fill in
the details later if you need to.
• Error checks. Some interviewers care a lot about this, while others don't. A good compromise here is to
add a t o d o and then just explain out loud what you'd like to test.
• Use other classes/structs where appropriate, if you need to return a list of start and end points from
a function, you could do this as a two-dimensional array, it's better though to do this as a list of
S t a r t E n d P a i r (or possibly Range) objects. You don't necessarily have to fill in the details for the class.
Just pretend it exists and deal with the details later if you have time.
• Good variable names. Code that uses single-letter variables everywhere is difficult to read. That's not to
say that there's anything wrong with using i and j, where appropriate (such as in a basic for-loop iter-
ating through an array). However, be careful about where you do this. If you write something like i n t
i = s t a r t O f C h i l d ( a r r a y ) , there might be a better name for this variable, such as s t a r t C h i l d .
Long variable names can also be slow to write though. A good compromise that most interviewers will
be okay with is to abbreviate it after the first usage. You can use s t a r t C h i l d the first time, and then
explain to your interviewer that you wilt abbreviate this as sc after this.
The specifics of what makes good code vary between interviewers and candidates, and the problem itself.
Focus on writing beautiful code, whatever that means to you.
If you see something you can refactor later on, then explain this to your interviewer and decide whether or
not it's worth the time to do so. Usually it is, but not always.
If you get confused (which is common), go back to your example and walk through it again.

7. Test
You wouldn't check in code in the real world without testing it, and you shouldn't "submit"code in an inter-
view without testing it either.
There are smart and not-so-smart ways to test your code though.
What many candidates do is take their earlier example and test it against their code. That might discover
bugs, but it'll take a really long time to do so. Hand testing is very slow. If you really did use a nice, big
example to develop your algorithm, then it'll take you a very long time to find that little off-by-one error at
the end of your code.
Instead, try this approach:
1. Start with a "conceptual" test. A conceptual test means just reading and analyzing what each line of code
does. Think about it like you're explaining the lines of code for a code reviewer, Does the code do what
you think it should do?
2. Weird looking code. Double check that line of code that says x = l e n g t h - 2. Investigate that for
loop that starts at i = 1. White you undoubtedly did this for a reason, it's really easy to get it just slightly
wrong.
3. Hot spots. You've coded long enough to know what things are likely to cause problems. Base cases
in recursive code. Integer division. Null nodes in binary trees. The Start and end of iteration through a
linked list. Double check that stuff.
4. Small test cases. This is the first time we use an actual, specific test case to test the code. Don't use that
nice, big 8-element array from the algorithm part. Instead, use a 3 or 4 element array. It'll likely discover
the same bugs, but it will be much faster to do so.
5. Special cases. Test your code against null or single element values, the extreme cases, and other special
cases.
When you find bugs (and you probably will), you should of course fix them. But don't just make the first
correction you think of. Instead, carefully analyze why the bug occurred and ensure that your fix is the best
one.

• Optimize & Solve Tech nique # 1: Look for BU D
This is perhaps the most useful approach I've found for optimizing problems. "BUD" is a silly acronym for:
• Bottlenecks
• Unnecessary work
* Duplicated work
These are three of the most common things that an algorithm can "waste" time doing. You can walk through
your brute force looking for these things. When you find one of them, you can then focus on getting rid of it.
If it's still not optimal, you can repeat this approach on your current best algorithm.
Bottlenecks
A bottleneck is a part of your algorithm that slows down the overall runtime. There are two common ways
this occurs:
* You have one-time work that slows down your algorithm. For example, suppose you have a two-step
algorithm where you first sort the array and then you find elements with a particular property. The first
stepisO(N l o g N) and the second step is 0(N). Perhaps you could reduce the second step to 0( l o g
N) or 0 ( 1 ) , but would it matter? Not too much. It's certainty not a priority, as the 0(N l o g N) is the
bottleneck. Until you optimize the first step, your overall algorithm will be 0(N l o g N).
• You have a chunk of work that's done repeatedly, like searching. Perhaps you can reduce that from 0(N)
t o 0 ( l o g N) or even 0 ( 1 ) . That will greatly speed up your overall runtime.
Optimizing a bottleneck can make a big difference in your overall runtime.
Example: Given an array of distinct integer values, count the number of pairs of integers that
have difference k. For example, given the array { 1 , 7, 5, 9, 2, 12, 3} and the difference
k = 2, there are four pairs with difference 2: ( 1 , 3 ) j ( 3 , S ) , ( 5 , 7), ( 7 , 9),
A brute force algorithm is to go through the array, starting from the first element, and then search through
the remaining elements (which will form the other side of the pair). For each pair, compute the difference.
If the difference equals k, increment a counter of the difference.
The bottleneck here is the repeated search for the "other side" of the pair. It's therefore the main thing to
focus on optimizing.
How can we more quickly find the right "other side"? Well, we actually know the other side of ( x , ?). It's
x + k or x - k. If we sorted the array, we could find the other side for each of the N elements i n O ( l o g
N) time by doing a binary search.
We now have a two-step algorithm, where both steps take 0(N l o g H) time. Now, sorting is the new
bottleneck. Optimizing the second step won't help because the first step is slowing us down anyway.
We just have to get rid of the first step entirely and operate on an unsorted array. How can we find things
quickly in an unsorted array? With a hash table. (page 80 for example)

Duplicated Work
Using the same problem and brute force algorithm as above, let's look for duplicated work this time.
The algorithm operates by essentially iterating through all ( a , b) pairs and then searching all ( c , d)
pairs to find if there are any matches to that { a , b) pair.
Why do we keep on computing all ( c , d) pairs for each ( a , b) pair? We should just create the list of ( c,
d) pairs once. Then, when we have an ( a , b) pair, find the matches within the ( c , d) fist.Wecan quickly
locate the matches by inserting each ( c , d) pair into a hash table that maps from the sum to the pair {or,
rather, the list of pairs that have that sum). (page 80 for example)

• Optimize & Solve Technique #2: DIY (Do It Yourself)
The first time you heard about how to find an element in a sorted array (before being taught binary search),
you probably didn't jump to, "Ah ha! We'll compare the target element to the midpoint and thenrecurseon
the appropriate half."
And yet, you could give someone who has no knowledge of computer science an alphabetized pile of
student papers and they'll likely implement something like binary search to locate a student's paper.
They'll probably say, "Gosh, Peter Smith? He'll be somewhere in the bottom of the stack."They'll pick a
random paper in the middle(ish), compare the name to "Peter Smith" and then continue this process on the
remainder of the papers. Although they have no knowledge of binary search, they intuitively "get it."
Our brains are funny like this. Throw the phrase "Design an algorithm" in there and people often get ail
jumbled up. But give people an actual example—whether just of the data (e.g., an array) or of the real-life
parallel (e.g., a pile of papers)—and their intuition gives them a very nice algorithm.
I've seen this come up countless times with candidates. Their computer algorithm is extraordinarily slow,
but when asked to solve the same problem manually, they immediately do something quite fast. (And it's
not too surprisingly, in some sense. Things that are slow for a computer are often slow by hand. Why would
you put yourself through extra work?)
Therefore, when you get a question, try just working it through intuitively on a real example. Often a bigger
example will be easier.

Example: Given a smaller string s and a bigger string b, design an algorithm to find all permuta-
tions of the shorter string within the longer one. Print the location of each permutation.
Think for a moment about how you'd solve this problem. Note permutations are rearrangements of the
string, so the characters in s can appear in any order in b. They must be contiguous though (not split by
other characters).
If you're like most candidates, you probably thought of something like: Generate all permutations of s and
then lookfor each in b. Since there are S! permutations, this will take 0(S ! * B) time, where S is the length
of s and B is the length of b.
This works, but it's an extraordinarily slow algorithm, it's actually worse than an exponential algorithm. If s
has 14 characters, that's over 87 billion permutations. Add one more character into s and we have 15 times
more permutations. Ouch!
Approached a different way, you could develop a decent algorithm fairly easily. Give yourself a big example,
like this one:
s: abbe
b: cbabadcbbabbcbabaabccbabc
Where are the permutations of s within b? Don't worry about how you're doing it. Just find them. Even a 12
year old could do this!
(No, really, go find them. I'll wait!)
I've underlined below each permutation,
s: abbe
b: cbabadcbbabbcbabaabccbabc (didn't actually show in book)
Did you find these? How?
Fewpeople—even those who earlier came up with the 0 ( S ! * 8) algorithm—actually generate alf the
permutations of abbe to locate those permutations in b. Almost everyone takes one of two (very simitar)
approaches:
1. Walk through b and took at sliding windows of 4 characters (since s has length 4). Check if each window
is a permutation of s.
2. Walk through b. Every time you see a character in s, check if the next four (the length of s) characters
area permutation of s.
Depending on the exact implementation of the "is this a permutation" part, you'll probably get a runtime of
either 0(B * S),0(B * S l o g S),orO(B * S2). None of these are the most optimal algorithm [there
is an 0(B) algorithm), but it's a lot better than what we had before.
Try this approach when you're solving questions. Use a nice, big example and intuitively—manually, that
is—solve it for the specific example. Then, afterwards, think hard about how you solved it. Reverse engineer
your own approach.
Be particularly aware of any "optimizations" you intuitively or automatically made. For example, when you
were doing this problem, you might have just skipped right over the sliding window with " d " in it, since
" d " isn't in abbe.That's an optimization your brain made, and it's something you should at least be aware
of in your algorithm.

• Optimize & Solve Technique #3: Simplify and Generalize
With Simplify and Generalize, we implement a multi-step approach. First, we simplify or tweak some
constraint, such as the data type. Then, we solve this new simplified version of the problem. Finally, once we
have an algorithm for the simplified problem, we try to adapt it for the more complex version.
Example: A ransom note can be formed by cutting words out of a magazine to form a new
sentence. How would you figure out if a ransom note (represented as a string) can be formed
from a given magazine (string)?
To simplify the problem, we can modify it so that we are cutting characters out of a magazine instead of
whole words.
We can solve the simplified ransom note problem with characters by simply creating an array and counting
the characters. Each spot in the array corresponds to one letter. First, we count the number of times each
character in the ransom note appears, and then we go through the magazine to see if we have all of those
characters.
When we generalize the algorithm, we do a very similar thing. This time, rather than creating an array with
character counts, we create a hash table that maps from a word to its frequency.

• Optimize & Solve Technique #4: Base Case and Build
With Base Case and Build, we solve the problem first for a base case (e.g., n = 1) and then try to build up
from there. When we get to more complex/interesting cases (often n = 3 or n = 4), we try to build those
using the prior solutions,
IExample: Design an algorithm to print all permutations of a string. For simplicity, assume all char-
acters are unique.
Considera test string a b c d e f g.
Case " a "
- - > { " a " }
Case "ab" - - > { " a h " , " b a " }
Case "abe"
--> ?
This is the first "interesting" case. If we had the answer to P ( " a b " ) , how could we generate P ( " a b c " ) ?
Well, the additional letter is"c,"so we can just stick c in at every possible point. That is:
P("abc") = insert "c" into all locations of all strings in p("ab")
P("abc") = insert "c" into all locations of all strings in {"ab'V'ba"}
J
P("abc") = merge ({"cab", "acb", "abc"}, {"cba
'
, "be a", bac"»
P("abc") = {"cab", "acb", "abc", "cba", "bea", bac"}
Now that we understand the pattern, we can develop a general recursive algorithm. We generate all permu-
tations of a string s i. . . Sn by "chopping off" the last character and generating all permutations of s l. . .
sn l. Once we have the list of all permutations of S l. .. S • f we iterate through this list. For each string in it,
we insert sn into every location of the string.
Base Case and Build algorithms often lead to natural recursive algorithms.

• Optimize & Solve Technique #5: Data Structure Brainstorm
This approach is certainly hacky, but it often works. We can simply run through a list of data structures and
try to apply each one. This approach is useful because solving a problem may be trivial once it occurs to us
to use, say, a tree.
Example: Numbers are randomly generated and stored into an (expanding) array. How would
you keep track of the median?
Our data structure brainstorm might look like the fotlowing:
• Linked list? Probably not. Linked lists tend not to do very well with accessing and sorting numbers.
* Array? Maybe, but you already have an array. Could you somehow keep the elements sorted? That's
probably expensive. Let's hold off on this and return to it if it's needed,
• Binary tree? This is possible, since binary trees do fairly well with ordering. In fact, if the binary search
tree is perfectly balanced, the top might be the median. But, be careful—if there's an even number of
elements, the median is actually the average of the middle two elements. The middle two elements can't
both be at the top. This is probably a workable algorithm, but let's come back to it.
• Heap? A heap is really good at basic ordering and keeping track of max and mins. This is actually
interesting—if you had two heaps, you could keep track of the bigger half and the smaller half of the
elements. The bigger half is kept in a min heap, such that the smallest element in the bigger half is at
the root. The smaller ha If is kept in a max heap, such that the biggest element of the smaller half is at the
root. Now, with these data structures, you have the potential median elements at the roots. If the heaps
are no longer the same size, you can quickly "rebalance" the heaps by popping an element off the one
heap and pushing it onto the other.
Note that the more problems you do, the more developed your instinct on which data structure to apply
will be. You will also develop a more finely tuned instinct as to which of these approaches is the most useful.

• Best Conceivable Runtime (BCR) (too much info didn't add, not the most important thing)

• Handling Incorrect Answers
One of the most pervasive—and dangerous—rumors is that candidates need to get every question right.
That's not quite true.
First, responses to interview questions shouldn't be thought of as "correct" or "incorrect." When I evaluate
how someone performed in an interview, I never think, "How many questions did they get right?" It's not a
binary evaluation. Rather, it's about how optimal their final solution was, how long it took them to get there,
how much help they needed, and how clean was their code. There is a range of factors.
Second, your performance is evaluated in comparison to other candidates. For example, if you solve a ques-
tion optimally in 15 minutes, and someone else solves an easier question in five minutes, did that person do
better than you? Maybe, but maybe not. If you are asked really easy questions, then you might be expected
to get optimal solutions really quickly. But if the questions are hard, then a number of mistakes are expected.
Third, many—possibly most—questions are too difficult to expect even a strong candidate to immediately
spit out the optimal algorithm. The questions I tend to ask would take strong candidates typically 20 to 30
minutes to solve.
In evaluating thousands of hiring packets at Google, I have only once seen a candidate havea"f1awless"set
of interviews. Everyone else, including the hundreds who got offers, made mistakes.

• When You've Heard a Question Before
If you've heard a question before, admit this to your interviewer. Your interviewer is asking you these ques-
tions in order to evaluate your problem-solving skills. If you already know the question, then you aren't
giving them the opportunity to evaluate you.
Additionally, your interviewer may find it highly dishonest if you don't reveal that you know the question.
(And, conversely, you'll get big honesty points if you do reveaf this.)

• The "Perfect" Language for Interviews
At many of the top companies, interviewers aren't picky about languages. They're more interested in how
well you solve the problems than whether you know a specific language.
Other companies though are more tied to a language and are interested in seeing how well you can code
in a particular language.
If you're given a choice of languages, then you should probably pick whatever language you're most
comfortable with.
That said, if you have several good languages, you should keep in mind the following.
Prevalence
It's not required, but it is ideal for your interviewer to know the language you're coding in. A more widely
known language can be better for this reason.
Language Readability
Even if your interviewer doesn't know your programming language, they should hopefully be able to basi-
cally understand it. Some languages are more naturally readable than others, due to their similarity to other
languages.

• What Good Coding Looks Like
You probably know by now that employers want to see that you write "good, clean"code. But what does this
really mean, and how is this demonstrated in an interview?
Broadly speaking, good code has the following properties:
• Correct: The code should operate correctly on all expected and unexpected inputs.
• Efficient: The code should operate as efficiently as possible in terms of both time and space. This "effi-
ciency" includes both the asymptotic (big 0) efficiency and the practical, real-life efficiency. That is, a
constant factor might get dropped when you compute the big 0 time, but in real life, it can very much
matter.
• Simple: If you can do something in 10 lines instead of 100, you should. Code should be as quick as
possible for a developer to write.
* Readable: A different developer should be able to read your code and understand what it does and
how it does it. Readable code has comments where necessary, but it implements things in an easily
understandable way. That means that your fancy code that does a bunch of complex bit shifting is not
necessarily good code.
* Maintainable: Code should be reasonably adaptable to changes during the life cycle of a product and
should be easy to maintain by other developers, as well as the initial developer.
Striving for these aspects requires a balancing act. For example, it's often advisable to sacrifice some degree
of efficiency to make code more maintainable, and vice versa.
You should think about these elements as you code during an interview. The following aspects of code are
more specific ways to demonstrate the earlier list.

Modular
Writing modular code means separating isolated chunks of code out into their own methods. This helps
keep the code more maintainable, readable, and testable.

Flexible and Robust
Just because your interviewer only asks you to write code to check if a normal tic-tac-toe board has a
winner, doesn't mean you must assume that it's a 3x3 board. Why not write the code in a more general way
that implements it for an NxN board?
Writing flexible, general-purpose code may also mean using variables instead of hard-coded values or
using templates / generics to solve a problem. If we can write our code to solve a more general problem,
we should.
Of course, there is a limit. If the solution is much more complex for the general case, and it seems unneces-
sary at this point in time, it maybe better just to implement the simple, expected case.

Error Checking
One sign of a careful coder is that she doesn't make assumptions about the input. Instead, she validates that
the input is what it should be, either through ASSERT statements or if-statements.
Checks like these are critical in production code and, therefore, in interview code as well.
Of course, writing these error checks can be tedious and can waste precious time in an interview. The
important thing is to point out that you would write the checks. If the error checks are much more than a
quick if-statement, it may be best to leave some space where the error checks would go and indicate to your
interviewer that you'll fill them in when you're finished with the rest of the code,

• Don't Give Up!
I know interview questions can be overwhelming, but that's part of what the interviewer is testing. Do you
rise to a challenge, or do you shrink back in fear? It's important that you step up and eagerly meet a tricky
problem head-on. After all, remember that interviews are supposed to be hard. It shouldn't be a surprise
when you get a really tough problem.
For extra "points," show excitement about solving hard problems.

------------------------------------------------------------------------------------------------------------------------

The Offer and Beyond (pg 94)

Just when you thought you could sit back and relax after your interviews, now you're faced with the post-
interview stress: Should you accept the offer? Is it the right one? How do you decline an offer? What about
deadlines? We'll handle a few of these issues here and go into more details about how to evaluate an offer,
and how to negotiate it,
• Handling Offers and Rejection
Whether you're accepting an offer, declining an offer, or responding to a rejection, it matters what you do.
Offer Deadlines and Extensions
When companies extend an offer, there's almost always a deadline attached to it. Usually these deadlines
are one to four weeks out. If you're still waiting to hear back from other companies, you can ask for an exten-
sion. Companies will usually try to accommodate this, if possible.
Declining an Offer
Even if you aren't interested in working for this company right now, you might be interested in working for it
in a few years, (Or, your contacts might one day move to a more exciting company.) It's in your best interest
to decline the offer on good terms and keep a tine of communication open.
When you decline an offer, provide a reason that Is non-offensive and inarguable. For example, if you were
declining a big company for a startup, you could explain that you feel a startup is the right choice for you
at this time. The big company can't suddenly "become" a startup, so they can't argue about your reasoning.
Handling Rejection
Getting rejected is unfortunate, but it doesn't mean that you're not a great engineer. Lots of great engineers
do poorly, either because they don't "test well" on these sort of interviewers, or they just had an "off" day.
Fortunately, most companies understand that these interviews aren't perfect and many good engineers get
rejected. For this reason, companies are often eager to re-interview previously rejected candidate. Some
companies will even reach out to old candidates or expedite their application because of their prior perfor-
mance.
When you do get the unfortunate call, use this as an opportunity to buifd a bridge to re-apply. Thank your
recruiter for his time, explain that you're disappointed but that you understand their position, and ask when
you can reapply to the company.

You can also ask for feedback from the recruiter. In most cases, the big tech companies won't offer feed-
back, but there are some companies that will. It doesn't hurt to ask a question like, "Is there anything you'd
suggest I work on for next time?"
• Evaluating the Offer
Congratulations! You got an offer! And—if you're lucky—you may have even gotten multiple offers. Your
recruiter's job is now to do everything he can to encourage you to accept it. How do you know if the
company is the right fit for you? We'll go through a few things you should consider in evaluating an offer.
The Financial Package
Perhaps the biggest mistake that candidates make in evaluating an offer is looking too much at their salary.
Candidates often look so much at this one number that they wind up accepting the offer that is worse finan-
cially, Salary is just one part of your financial compensation. You should also look at:
• Signing Bonus, Relocation, and Other One Time Perks: Many companies offer a signing bonus and/or relo-
cation. When comparing offers, it's wise to amortize this cash over three years (or however long you
expect to stay).
• Cost of Living Difference: Taxes and other cost of living differences can make a big difference in your take-
home pay. Silicon Valley, for example, is 30+% more expensive than Seattle.
• Annual Bonus: Annual bonuses at tech companies can range from anywhere from 3% to 30%. Your
recruiter might reveal the average annual bonus, but if not, check with friends at the company.
• Stock Options and Grants: Equity compensation can form another big part of your annual compensation.
Like signing bonuses, stock compensation between companies can be compared by amortizing it over
three years and then lumping that value into salary.
Remember, though, that what you learn and how a company advances your career often makes far more of
a difference to your long term finances than the salary. Think very carefully about how much emphasis you
really want to put on money right now.
Career Development
As thrilled as you may be to receive this offer, odds are, in a few years, you'll start thinking about inter-
viewing again. Therefore, it's important that you think right now about how this offer would impact your
career path. This means considering the following questions:
• How good does the company's name look on my resume?
• How much will I learn? Will I learn relevant things?
• What is the promotion plan? How do the careers of developers progress?
• If I want to move into management, does this company offer a realistic plan?
• Is the company or team growing?
• If I do want to leave the company, is it situated near other companies I'm interested in, or will I need to
move?
The final point is extremely important and usually overlooked. If you only have a few other companies to
pick from in your city, your career options will be more restricted. Fewer options means that you're less likely
to discover really great opportunities.
Company Stability
All else being equal, of course stability is a good thing. No one wants to be fired or laid off.
However, all else isn't actually equal. The more stable companies are also often growing more slowly.
How much emphasis you should put on company stability really depends on you and your values. For some
candidates, stability should not be a large factor. Can you fairly quickly find a new job? If so, it might be
better to take the rapidly growing company, even if it's unstable? If you have work visa restrictions or just
aren't confident in your ability to find something new, stability might be more important.
The Happiness Factor
Last but not least, you should of course consider how happy you will be. Any of the following factors may
impact that:
• TTie Product; Many people look heavily at what product they are building, and of course this matters a bit.
However, for most engineers, there are more important factor, such as who you work with.
• Manager and Tea mm ates: When people say that they love, or hate, their job, it's often because of their
teammates and their manager. Have you met them? Did you enjoy talking with them?
• Company Culture: Culture is tied to everything from how decisions get made, to the social atmosphere,
to how the company is organized. Ask your future teammates how they would describe the culture.
• Hours: Ask future teammates about how long they typically work, and figure out if that meshes with your
lifestyle. Remember, though, that hours before major deadlines are typically much longer.
Additionally, note that if you are given the opportunity to switch teams easily (like you are at Google and
Facebook), you'll have an opportunity to find a team and product that matches you well.
• Negotiation
Years ago, I signed up for a negotiations class. On the first day, the instructor asked us to imagine a scenario
where we wanted to buy a car. Dealership A sells the car for a fixed $20,000—no negotiating. Dealership B
allows us to negotiate. How much would the car have to be (after negotiating) for us to goto Dealership B?
(Quick! Answer this for yourself!)
On average, the class said that the car would have to be $750 cheaper. In other words, students were willing
to pay $750 just to avoid having to negotiate for an hour or so. Not surprisingly, in a class poll, most of these
students also said they didn't negotiate their job offer. They just accepted whatever the company gave
them.
Many of us can probably sympathize with this position. Negotiation isn't fun for most of us. But still, the
financial benefits of negotiation are usually worth it.
Do yourself a favor. Negotiate. Here are some tips to get you started.
L Just Do It. Yes, I know it's scary; (almost) no one likes negotiating. But it's so, so worth it. Recruiters will not
revoke an offer because you negotiated, so you have little to lose. This is especially true if the offer is from
a larger company. You probably won't be negotiating with your future teammates.
2. Have a Viable Alternative. Fundamentally, recruiters negotiate with you because they're concerned you
may not join the company otherwise. If you have alternative options, that will make their concern much
more real.
3. Have a Specific "Ask": It's more effective to ask for an additional $7000 in salary than to just ask for "more."
After all, if you just ask for more, the recruiter could throw in another $1000 and technically have satis-
fied your wishes.
4. Overshoot: In negotiations, people usually don't agree to whatever you demand. It's a back and forth
conversation. Ask for a bit more than you're reaily hoping to get, since the company will probably meet
you in the middle.
5. Think Beyond Salary: Companies are often more willing to negotiate on non-salary components, since
boosting your salary too much could mean that they're paying you more than your peers. Consider
asking for more equity or a bigger signing bonus. Alternatively, you may be able to ask for your reloca-
tion benefits in cash, instead of having the company pay directly for the moving fees. This is a great
avenue for many college students, whose actual moving expenses are fairly cheap,
6. Use Your Best Medium: Many people will advise you to only negotiate over the phone. To a certain extent,
they're right; it is better to negotiate over the phone. However, if you don't feel comfortable on a phone
negotiation, do it via email. It's more important that you attempt to negotiate than that you do it via a
specific medium.
Additionally, if you're negotiating with a big company, you should know that they often have "levels" for
employees, where all employees at a particular level are paid around the same amount. Microsoft has a
particularly well-defined system for this. You can negotiate within the salary range for your level, but going
beyond that requires bumping up a level. If you're looking for a big bump, you'll need to convince the
recruiter and your future team that your experience matches this higher level—a difficult, but feasible,
thing to do.

------------------------------------------------------------------------------------------------------------------------

Arrays and Strings (page 100)

• Hash Tables
A hash table is a data structure that maps keys to values for highly efficient lookup. There are a number of
ways of implementing this. Here, we will describe a simple but common implementation.